# [오브젝트] Chapter 02. 객체지향 프로그래밍
저자: 조영호

---

# 1. 영화 예매 시스템
사용자는 영화를 고르고, 영화를 상영하기 위해 시간대를 고른다.   
영화와 상영에 따라 정해진 할인 정책, 할인 조건이 달라진다.   
할인 정책과 조건에 의해 할인 여부, 할인 금액이 결정된다.   

### 할인 조건 (Discount Condition)
가격의 할인 여부를 결정한다.
- 순서 조건
  - 상영 순번을 이용해 할인 여부를 결정
- 기간 조건
  - 영화 상영 시작 시간을 이용해 할인 여부를 결정

### 할인 정책 (Discount Policy)
할인 요금을 결정한다.   
영화 별로 하나의 할인 정책만 할당할 수 있으며, 할인 정책을 지정하지 않는 것도 가능하다.
- 금액 할인 정책
  - 예매 요금에서 일정 금액을 할인해주는 방식
- 비율 할인 정책
  - 정가에서 일정 비율의 요금을 할인해주는 방식

# 2. 객체지향 프로그래밍을 향해
객체지향은 말 그대로 객체를 지향하는 것이다. 진정한 객체지향 패러다임으로의 전환은 '클래스'가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.
1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
   1. 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다. 
3. 객체들의 모양과 윤곽이 잡히면 공통된 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현하라.

## 도메인의 구조를 따르는 프로그램 구조
도메인: 사용자가 프로그램을 사용하는 분야   
영화 예매 도메인을 구성하는 개념과 관계는 아래와 같다. (그림 생략)
- 영화는 여러 번 상영될 수 있다
- 상영은 여러 번 예매될 수 있다
- 영화에는 할인 정책을 할당하지 않거나 할당하더라도 오직 하나만 할당할 수 있다
- 할인 정책이 존재하는 경우에는 하나 이상의 할인 조건이 반드시 존재한다
- 할인 정책의 종류로는 금액 할인 정책과 비율 할인 정책이 있다
- 할인 조건의 종류로는 순번 조건과 기간 조건이 있다

그리고 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 한다.    
클래스 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다.

## 클래스 구현하기
### 상영 (Screening)
상영할 영화(movie), 순번(sequence), 상영 시작 시간(whenScreened)을 인스턴스 변수로 포함   
상영 시작 시간을 반환하는 `getStartTime` 메서드, 순번의 일치 여부를 검사하는 `isSequence` 메서드, 기본 요금을 반환하는 `getMovieFee` 메서드를 포함

```java
import java.time.LocalDateTime;

public class Screening {
    private Movie movie;
    private int sequence;
    private LocalDateTime whenScreened;
    
    public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {
        this.movie = movie;
        this.sequence = sequence;
        this.whenScreened = whenScreened;
    }
    
    public LocalDateTime getStartTime() {
        return whenScreened;
    }
    
    public boolean isSequence(int sequence) {
        return this.sequence == sequence;
    }
    
    public Money getMovieFee() {
        return movie.getFee();
    }
}
```

**주목할 점**   
인스턴스 변수의 가시성은 `private`이고, 메서드의 가시성은 `public`이다.   
클래스를 구현하거나 다른 개발자에 의해 개발된 클래스를 사용할 때 가장 중요한 것은 '클래스의 경계를 구분 짓는 것'이다.
핵심은 '어떤 부분을 외부에 공개하고 어떤 부분을 감출지'를 결정하는 것이다.   
왜?   
경계의 명확성이 객체의 자율성을 보장하기 때문이다. -> 프로그래머에게 구현의 자유를 제공한다.

### 자율적인 객체
1. 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재
2. 객체는 스스로 판단하고 행동하는 자율적인 존재

객체지향은 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음으로써 문제의 영역의 아이디어를 적절하게 표현할 수 있게 했다. (=캡슐화)   
대부분의 객체지향 프로그래밍 언어들은 외부에서 접근을 통제할 수 있는 '접근 제어' 메커니즘도 함께 제공한다.

객체 내부에 대한 접근을 통제하는 이유는 **객체를 자율적인 존재로 만들기 위해서**다.   
객체지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것이다.

캡슐화와 접근 제어는 객체를 두 부분으로 나눈다.
1. 퍼블릭 인터페이스: 외부에서 접근 가능한 부분
2. 구현: 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분

일반적으로 객체의 상태는 숨기고 행동만 외부에 공개해야 한다.

### 프로그래머의 자유
프로그래머의 역할을 클래스 작성자와 클라이언트 프로그래머로 구분하는 것이 유용하다. 
클래스 작성자는 새로운 데이터 타입을 프로그램에 추가하고, 클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입을 사용한다.

* 클라이언트 프로그래머: 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축
* 클래스 작성자: 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨긴다 -> 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경 가능

이를 **구현 은닉**이라고 부른다.

설계가 필요한 이유는 변경을 관리하기 위해서라는 것을 기억하라.   
객체지향 언어는 객체 사이의 의존성을 적절히 관리함으로써 변경에 대한 파급효과를 제어할 수 있는 다양한 방법을 제공한다.

## 협력하는 객체들의 공동체
영화를 예매하는 기능을 구현하는 메서드를 살펴보자.
```java
public class Screening {
    public Reservation reserve(Customer customer, int audienceCount) {
        return new Reservation(customer, this, calculateFee(audienceCount), audienceCount);
    }
    
    private Money calculateFee(int audienceCount) {
        return movie.calculateMovieFee(this).times(audienceCount);
    }
}
```
- `calculateFee`라는 메서드를 호출해서 요금을 계산한 후 그 결과를 `Reservation`의 생성자에 전달한다.
- `calculateFee` 메서드는 요금 계산을 위해 다시 `Movie`의 `calculateMovieFee` 메서드를 호출한다.
- `Movie`의 `calculateMovieFee` 메서드의 반환 값은 1인 당 예매 요금이다. (곱한단 소리...)

`Money`는 금액과 관련된 다양한 계산을 구현하는 간단한 클래스다.   
(Money 구현 내용 생략)   

1장에서는 금액을 구현하기 위해 Long 타입을 사용했다. Long 타입을 사용하면 변수의 크기나 연산자 종류와 관련된 구현 관점의 제약은 표현할 수 있다.
그러나 저장하는 값이 '금액과 관련 되어 있다'는 의미는 전달할 수 없다. 또한 금액과 관련된 로직이 서로 다른 곳에 중복 구현되는 것을 막을 수 없다.

`Reservation` 클래스는 고객(customer), 상영 정보(screening), 예매 요금(fee), 인원 수(audienceCount)를 속성으로 포함한다.   
(Reservation 구현 내용 생략)   

영화를 예매하기 위해 `Screening`, `Movie`, `Reservation` 인스턴스들은 서로의 메서드를 호출하며 상호 작용한다.   
-> 이를 **협력**이라고 부른다.

## 협력에 관한 짧은 이야기
객체가 다른 객체와 상호작용 할 수 있는 유일한 방법은 메시지를 전송(send a message)하는 것 뿐이다.   
다른 객체에게 요청이 도착할 때 해당 객체가 메시지를 수신(receive a message)했다고 이야기 한다.   
메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정한다.   
이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드(method)** 라고 부른다.

메시지와 메서드를구분하는 것은 매우 중요하다. 메시지와 메서드의 구분에서부터 다형성의 개념이 출발한다.
